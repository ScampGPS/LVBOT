"""
Reservation Queue Management Module

This module provides the ReservationQueue class for managing queued reservation requests.
It handles storage, retrieval, and status updates of reservation requests with JSON persistence.
"""

import json
import uuid
import logging
from typing import List, Dict, Any, Optional
from pathlib import Path


class ReservationQueue:
    """
    Manages the storage, retrieval, and status updates of reservation requests.
    
    This class provides a persistent queue for managing tennis court reservation requests,
    storing them in a JSON file and providing methods for queue operations.
    
    Attributes:
        file_path (str): Path to the JSON file for persistence
        queue (List[Dict[str, Any]]): In-memory list of reservation dictionaries
        logger (logging.Logger): Logger instance for this class
    """
    
    def __init__(self, file_path: str = 'queue.json'):
        """
        Initialize the ReservationQueue.
        
        Args:
            file_path (str): Path to the JSON file for persistence. Defaults to 'queue.json'.
        """
        self.file_path = file_path
        self.logger = logging.getLogger('ReservationQueue')
        self.queue = self._load_queue()
        self.logger.info(f"ReservationQueue initialized with {len(self.queue)} existing reservations")
    
    def add_reservation(self, reservation_data: Dict[str, Any]) -> str:
        """
        Add a new reservation to the queue.
        
        Args:
            reservation_data (Dict[str, Any]): Reservation data dictionary
            
        Returns:
            str: Unique reservation ID assigned to the new reservation
        """
        from datetime import datetime, timedelta
        import pytz
        from lvbot.utils.constants import TEST_MODE_ENABLED, TEST_MODE_TRIGGER_DELAY_MINUTES
        
        reservation_id = uuid.uuid4().hex
        reservation = {
            'id': reservation_id,
            'status': 'pending',
            **reservation_data
        }
        
        # Calculate scheduled execution time
        tz = pytz.timezone('America/Guatemala')
        
        if TEST_MODE_ENABLED:
            # In test mode, schedule execution X minutes from now
            scheduled_time = datetime.now(tz) + timedelta(minutes=TEST_MODE_TRIGGER_DELAY_MINUTES)
            reservation['status'] = 'scheduled'
            self.logger.info(f"TEST MODE: Scheduling execution in {TEST_MODE_TRIGGER_DELAY_MINUTES} minutes")
        else:
            # Normal mode: schedule 48 hours before the target time
            target_date = datetime.strptime(reservation_data['target_date'], '%Y-%m-%d').date()
            target_time = datetime.strptime(reservation_data['target_time'], '%H:%M').time()
            target_datetime = datetime.combine(target_date, target_time)
            target_datetime = tz.localize(target_datetime)
            
            # Schedule execution 48 hours before target time
            scheduled_time = target_datetime - timedelta(hours=48)
            
            # If scheduled time is in the past, schedule immediately
            if scheduled_time <= datetime.now(tz):
                scheduled_time = datetime.now(tz) + timedelta(seconds=30)
                reservation['status'] = 'scheduled'
            else:
                reservation['status'] = 'scheduled'
        
        reservation['scheduled_execution'] = scheduled_time.isoformat()
        
        self.queue.append(reservation)
        self._save_queue()
        
        self.logger.info(f"Added reservation {reservation_id} for user {reservation_data.get('user_id')}, scheduled for {scheduled_time}")
        return reservation_id
    
    def get_reservation(self, reservation_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve a single reservation by its unique ID.
        
        Args:
            reservation_id (str): Unique reservation identifier
            
        Returns:
            Optional[Dict[str, Any]]: Reservation dictionary if found, None otherwise
        """
        for reservation in self.queue:
            if reservation.get('id') == reservation_id:
                return reservation
        return None
    
    def get_user_reservations(self, user_id: int) -> List[Dict[str, Any]]:
        """
        Retrieve all reservations associated with a given user_id.
        
        Args:
            user_id (int): Telegram user ID
            
        Returns:
            List[Dict[str, Any]]: List of reservation dictionaries for the user
        """
        user_reservations = [
            reservation for reservation in self.queue 
            if reservation.get('user_id') == user_id
        ]
        
        self.logger.debug(f"Found {len(user_reservations)} reservations for user {user_id}")
        return user_reservations
    
    def get_pending_reservations(self) -> List[Dict[str, Any]]:
        """
        Return all reservations with status 'pending' or 'scheduled'.
        
        Returns:
            List[Dict[str, Any]]: List of pending/scheduled reservation dictionaries
        """
        pending_reservations = [
            reservation for reservation in self.queue 
            if reservation.get('status') in ['pending', 'scheduled']
        ]
        
        self.logger.debug(f"Found {len(pending_reservations)} pending/scheduled reservations")
        return pending_reservations
    
    def update_reservation_status(self, reservation_id: str, new_status: str, **kwargs) -> bool:
        """
        Update the status of a reservation and optionally other fields.
        
        Args:
            reservation_id (str): Unique reservation identifier
            new_status (str): New status value
            **kwargs: Additional fields to update (e.g., attempts, confirmation_code)
            
        Returns:
            bool: True if update was successful, False if reservation not found
        """
        for reservation in self.queue:
            if reservation.get('id') == reservation_id:
                old_status = reservation.get('status')
                reservation['status'] = new_status
                
                # Update additional fields from kwargs
                for key, value in kwargs.items():
                    reservation[key] = value
                
                self._save_queue()
                self.logger.info(
                    f"Updated reservation {reservation_id} status from '{old_status}' to '{new_status}'"
                )
                return True
        
        self.logger.warning(f"Reservation {reservation_id} not found for status update")
        return False
    
    def remove_reservation(self, reservation_id: str) -> bool:
        """
        Remove a reservation from the queue by its ID.
        
        Args:
            reservation_id (str): Unique reservation identifier
            
        Returns:
            bool: True if removed successfully, False if reservation not found
        """
        for i, reservation in enumerate(self.queue):
            if reservation.get('id') == reservation_id:
                removed_reservation = self.queue.pop(i)
                self._save_queue()
                
                self.logger.info(
                    f"Removed reservation {reservation_id} for user {removed_reservation.get('user_id')}"
                )
                return True
        
        self.logger.warning(f"Reservation {reservation_id} not found for removal")
        return False
    
    def update_reservation(self, reservation_id: str, updated_data: Dict[str, Any]) -> bool:
        """
        Update an existing reservation with new data
        
        Args:
            reservation_id: The ID of the reservation to update
            updated_data: Dictionary with updated reservation data
            
        Returns:
            bool: True if update was successful, False if reservation not found
        """
        for i, reservation in enumerate(self.queue):
            if reservation.get('id') == reservation_id:
                # Update the reservation while preserving the ID
                updated_data['id'] = reservation_id
                self.queue[i] = updated_data
                self._save_queue()
                
                self.logger.info(f"Updated reservation {reservation_id}")
                return True
        
        self.logger.warning(f"Reservation {reservation_id} not found for update")
        return False
    
    def _save_queue(self) -> None:
        """
        Internal helper method to save the current queue state to JSON file.
        
        Handles file operation errors gracefully and logs any issues.
        """
        try:
            # Ensure directory exists
            Path(self.file_path).parent.mkdir(parents=True, exist_ok=True)
            
            with open(self.file_path, 'w', encoding='utf-8') as f:
                json.dump(self.queue, f, indent=2, ensure_ascii=False)
            
            self.logger.debug(f"Queue saved to {self.file_path} with {len(self.queue)} reservations")
            
        except Exception as e:
            self.logger.error(f"Failed to save queue to {self.file_path}: {e}")
    
    def _load_queue(self) -> List[Dict[str, Any]]:
        """
        Internal helper method to load the queue from JSON file.
        
        Returns:
            List[Dict[str, Any]]: List of reservation dictionaries, empty list if file doesn't exist
        """
        try:
            if Path(self.file_path).exists():
                with open(self.file_path, 'r', encoding='utf-8') as f:
                    queue_data = json.load(f)
                
                # Ensure we have a list
                if isinstance(queue_data, list):
                    self.logger.debug(f"Loaded {len(queue_data)} reservations from {self.file_path}")
                    return queue_data
                else:
                    self.logger.warning(f"Invalid queue format in {self.file_path}, starting with empty queue")
                    return []
            else:
                self.logger.debug(f"Queue file {self.file_path} does not exist, starting with empty queue")
                return []
                
        except Exception as e:
            self.logger.error(f"Failed to load queue from {self.file_path}: {e}")
            return []