"""
Dynamic Booking Orchestrator
Coordinates multiple browsers with refresh strategies and dynamic fallbacks
"""

import asyncio
import threading
from typing import List, Dict, Set, Optional, Any, Tuple
from datetime import datetime
import logging
from dataclasses import dataclass
from enum import Enum


class BookingStatus(Enum):
    PENDING = "pending"
    ATTEMPTING = "attempting"
    SUCCESS = "success"
    FAILED = "failed"
    FALLBACK = "fallback"


@dataclass
class BookingAttempt:
    """Track a booking attempt"""
    user_id: int
    reservation_id: str
    target_court: int
    fallback_courts: List[int]
    status: BookingStatus
    browser_id: Optional[str] = None
    attempt_time: Optional[datetime] = None
    result: Optional[Dict] = None


class DynamicBookingOrchestrator:
    """
    Orchestrates booking attempts across multiple browsers with dynamic fallbacks
    
    Strategy:
    1. Use 3 browsers with staggered refresh (0s, 2s, 4s delays)
    2. Assign primary targets to browsers
    3. If booking fails, dynamically reassign to available courts
    4. Track successes/failures in real-time to avoid conflicts
    """
    
    def __init__(self):
        self.logger = logging.getLogger('BookingOrchestrator')
        self.lock = threading.Lock()
        
        # Track booking status
        self.active_attempts: Dict[str, BookingAttempt] = {}  # reservation_id -> attempt
        self.court_status: Dict[int, str] = {}  # court -> 'available'/'attempting'/'booked'
        self.successful_bookings: Set[str] = set()  # reservation_ids that succeeded
        
        # Browser refresh strategies (like our monitoring that worked best)
        # Support both 2 and 3 browser configurations
        self.browser_strategies = [
            {"id": "Browser1-Refresh0", "delay": 0, "refresh_interval": 5},
            {"id": "Browser2-Refresh2", "delay": 2, "refresh_interval": 5},
            {"id": "Browser3-Refresh4", "delay": 4, "refresh_interval": 5}
        ]
        
        # For GCE with limited resources - optimized based on monitoring data
        # Slots appear 1-2 seconds BEFORE the hour
        self.browser_strategies_limited = [
            {"id": "Browser1-EarlyBird", "delay": 0, "start_offset": -3},  # Starts 3s before hour
            {"id": "Browser2-OnTime", "delay": 1, "start_offset": -1}      # Starts 1s before hour
        ]
        
        # Precision refresh timing based on monitoring data
        # Slots appear 1.4s before the hour, refresh takes ~1s
        self.precision_refresh_config = {
            'slot_appears_at': -1.4,     # Slots appear 1.4s before hour
            'refresh_duration': 1.0,     # Refresh takes ~1 second
            'refresh_at': -2.0,          # Start refresh at -2.0s (safer timing)
            'safety_margin': 0.0,        # Already built into -2.0s timing
            'start_early': 15,           # Still start 15s early for navigation
            'position_by': 10,           # Be on calendar by -10s
        }
        
        # Legacy smart refresh config (kept for compatibility)
        self.smart_refresh_config = {
            'navigation_time': 11,       # Worst-case navigation time
            'pre_window_start': -15,     # Start monitoring 15s before (to account for navigation)
            'rapid_check_start': -3,     # Rapid checks from 3s before
            'critical_start': -2,        # Ultra-rapid from 2s before
            'critical_end': 2,           # Ultra-rapid until 2s after
            'post_window_end': 5,        # Stop rapid checks 5s after
            'intervals': {
                'normal': 2.0,           # 2 seconds
                'pre_rapid': 0.5,        # 500ms
                'rapid': 0.2,            # 200ms
                'critical': 0.1,         # 100ms (during -2s to +2s window)
            }
        }
    
    def create_booking_plan(self, reservations: List[Any], time_slot: str) -> Dict[str, Any]:
        """
        Create dynamic booking plan for a time slot
        
        Args:
            reservations: List of reservations for the same time slot
            time_slot: Target time (e.g., "09:00")
            
        Returns:
            Booking plan with browser assignments and fallback strategies
        """
        with self.lock:
            self.logger.info(f"Creating booking plan for {len(reservations)} users at {time_slot}")
            
            # Reset court status
            self.court_status = {1: 'available', 2: 'available', 3: 'available'}
            
            # Sort by priority: admin (0) first, then VIP (1), then regular (2)
            # Within same priority level, sort by creation time (FCFS)
            sorted_reservations = sorted(
                reservations,
                key=lambda r: (getattr(r, 'priority', 2), getattr(r, 'created_at'))
            )
            
            # Create booking attempts
            attempts = []
            assigned_courts = set()
            
            for res in sorted_reservations[:3]:  # Max 3 concurrent bookings
                # Assign primary court
                primary_court = None
                for court in getattr(res, 'courts', []):
                    if court not in assigned_courts:
                        primary_court = court
                        assigned_courts.add(court)
                        break
                
                if not primary_court and len(assigned_courts) < 3:
                    # Assign any available court
                    for court in [1, 2, 3]:
                        if court not in assigned_courts:
                            primary_court = court
                            assigned_courts.add(court)
                            break
                
                if primary_court:
                    # Create fallback list (other courts in preference order)
                    fallback_courts = [c for c in getattr(res, 'courts', []) if c != primary_court]
                    # Add any remaining courts
                    for court in [1, 2, 3]:
                        if court not in fallback_courts and court != primary_court:
                            fallback_courts.append(court)
                    
                    attempt = BookingAttempt(
                        user_id=getattr(res, 'user_id'),
                        reservation_id=getattr(res, 'id'),
                        target_court=primary_court,
                        fallback_courts=fallback_courts,
                        status=BookingStatus.PENDING
                    )
                    attempts.append(attempt)
                    self.active_attempts[getattr(res, 'id')] = attempt
                    self.court_status[primary_court] = 'attempting'
            
            # Distribute attempts across browsers
            browser_assignments = []
            for i, attempt in enumerate(attempts):
                browser = self.browser_strategies[i % len(self.browser_strategies)]
                browser_assignments.append({
                    'browser': browser,
                    'attempt': attempt,
                    'strategy': 'refresh_staggered'
                })
            
            plan = {
                'time_slot': time_slot,
                'total_attempts': len(sorted_reservations),
                'initial_attempts': len(attempts),
                'browser_assignments': browser_assignments,
                'overflow_count': len(sorted_reservations) - len(attempts) if len(sorted_reservations) > len(attempts) else 0
            }
            
            self._log_plan(plan)
            return plan
    
    def handle_booking_result(self, reservation_id: str, success: bool, 
                            court_booked: Optional[int] = None) -> Optional[Dict]:
        """
        Handle booking result and determine if fallback is needed
        
        Returns:
            Fallback plan if needed, None otherwise
        """
        with self.lock:
            attempt = self.active_attempts.get(reservation_id)
            if not attempt:
                return None
            
            if success:
                # Mark as successful
                attempt.status = BookingStatus.SUCCESS
                self.successful_bookings.add(reservation_id)
                if court_booked:
                    self.court_status[court_booked] = 'booked'
                self.logger.info(f"Booking {reservation_id} succeeded on court {court_booked}")
                return None
            
            else:
                # Booking failed - check for fallback options
                self.logger.info(f"Booking {reservation_id} failed on court {attempt.target_court}")
                
                # Mark current court as still available (failed to book)
                if attempt.target_court in self.court_status:
                    self.court_status[attempt.target_court] = 'available'
                
                # Find next available court from fallbacks
                fallback_court = None
                for court in attempt.fallback_courts:
                    if self.court_status.get(court) == 'available':
                        fallback_court = court
                        break
                
                if fallback_court:
                    # Create fallback plan
                    attempt.status = BookingStatus.FALLBACK
                    attempt.target_court = fallback_court
                    self.court_status[fallback_court] = 'attempting'
                    
                    return {
                        'reservation_id': reservation_id,
                        'fallback_court': fallback_court,
                        'remaining_fallbacks': [c for c in attempt.fallback_courts 
                                              if c != fallback_court and 
                                              self.court_status.get(c) == 'available']
                    }
                else:
                    # No fallbacks available
                    attempt.status = BookingStatus.FAILED
                    self.logger.warning(f"No fallback courts available for {reservation_id}")
                    return None
    
    def get_dynamic_court_assignment(self, reservation_id: str) -> Optional[int]:
        """Get current court assignment for a reservation"""
        with self.lock:
            attempt = self.active_attempts.get(reservation_id)
            return attempt.target_court if attempt else None
    
    def is_court_available(self, court: int) -> bool:
        """Check if a court is available for booking"""
        with self.lock:
            return self.court_status.get(court, 'available') == 'available'
    
    def get_booking_summary(self) -> Dict[str, Any]:
        """Get summary of booking attempts"""
        with self.lock:
            summary = {
                'total_attempts': len(self.active_attempts),
                'successful': len(self.successful_bookings),
                'failed': sum(1 for a in self.active_attempts.values() 
                            if a.status == BookingStatus.FAILED),
                'court_status': self.court_status.copy(),
                'attempts': []
            }
            
            for attempt in self.active_attempts.values():
                summary['attempts'].append({
                    'user_id': attempt.user_id,
                    'target_court': attempt.target_court,
                    'status': attempt.status.value,
                    'fallbacks_remaining': len([c for c in attempt.fallback_courts 
                                              if self.court_status.get(c) == 'available'])
                })
            
            return summary
    
    def get_precision_refresh_moment(self, target_time: datetime) -> datetime:
        """
        Calculate the exact moment to execute a single refresh
        Based on monitoring: slots appear 1.4s before the hour
        
        Returns:
            datetime: The precise moment to refresh
        """
        config = self.precision_refresh_config
        
        # Calculate when slot will appear
        slot_appears = target_time + timedelta(seconds=config['slot_appears_at'])
        
        # Calculate when to start refresh (slot_appears - refresh_duration - margin)
        refresh_moment = slot_appears - timedelta(
            seconds=config['refresh_duration'] + config['safety_margin']
        )
        
        self.logger.info(f"Precision timing for {target_time.strftime('%H:%M')}:")
        self.logger.info(f"  Slot appears: {slot_appears.strftime('%H:%M:%S.%f')[:-3]}")
        self.logger.info(f"  Refresh at: {refresh_moment.strftime('%H:%M:%S.%f')[:-3]}")
        
        return refresh_moment
    
    def should_refresh_now(self, target_time: datetime, current_time: datetime, 
                          last_refresh: Optional[datetime] = None) -> bool:
        """
        Determine if it's time for the precision refresh
        
        Returns:
            bool: True if should refresh now, False otherwise
        """
        refresh_moment = self.get_precision_refresh_moment(target_time)
        seconds_until_refresh = (refresh_moment - current_time).total_seconds()
        
        # If we haven't refreshed yet and it's time
        if last_refresh is None and seconds_until_refresh <= 0:
            return True
            
        # If we're way past the refresh moment and haven't refreshed
        if last_refresh is None and seconds_until_refresh < -5:
            self.logger.warning("Missed precision refresh window! Refreshing now.")
            return True
            
        return False
    
    def get_smart_refresh_interval(self, target_time: datetime, current_time: datetime) -> float:
        """
        Calculate optimal refresh interval based on proximity to target time
        Based on monitoring data: slots appear 1-2 seconds BEFORE the hour
        
        Returns:
            Refresh interval in seconds
        """
        seconds_until_target = (target_time - current_time).total_seconds()
        config = self.smart_refresh_config
        
        # Before the window - normal refresh
        if seconds_until_target > config['pre_window_start']:
            return config['intervals']['normal']
        
        # Pre-rapid phase (-5s to -3s)
        elif config['pre_window_start'] <= seconds_until_target < config['rapid_check_start']:
            return config['intervals']['pre_rapid']
        
        # Rapid phase (-3s to -2s)
        elif config['rapid_check_start'] <= seconds_until_target < config['critical_start']:
            return config['intervals']['rapid']
        
        # CRITICAL WINDOW (-2s to +2s) - Maximum speed!
        elif config['critical_start'] <= seconds_until_target <= config['critical_end']:
            return config['intervals']['critical']
        
        # Post-window slowdown (+2s to +5s)
        elif config['critical_end'] < seconds_until_target <= config['post_window_end']:
            return config['intervals']['rapid']
        
        # After the window - back to normal
        else:
            return config['intervals']['normal']
    
    def reset(self):
        """Reset orchestrator state"""
        with self.lock:
            self.active_attempts.clear()
            self.court_status = {1: 'available', 2: 'available', 3: 'available'}
            self.successful_bookings.clear()
    
    def _log_plan(self, plan: Dict):
        """Log the booking plan"""
        self.logger.info("=" * 60)
        self.logger.info(f"Booking Plan for {plan['time_slot']}:")
        self.logger.info(f"Total users: {plan['total_attempts']}")
        self.logger.info(f"Initial batch: {plan['initial_attempts']} users")
        
        for i, assignment in enumerate(plan['browser_assignments']):
            attempt = assignment['attempt']
            browser = assignment['browser']
            
            if i < plan['initial_attempts']:
                self.logger.info(
                    f"  {browser['id']} (delay {browser['delay']}s): "
                    f"User {attempt.user_id} → Court {attempt.target_court} "
                    f"(fallbacks: {attempt.fallback_courts})"
                )
            else:
                self.logger.info(
                    f"  [Overflow] User {attempt.user_id} → Court {attempt.target_court} "
                    f"(will attempt after initial batch)"
                )
        
        if plan['overflow_count'] > 0:
            self.logger.info(f"Overflow strategy: {plan['overflow_count']} users will be processed after initial batch completes")
        self.logger.info("=" * 60)