
"""
Reservation Scheduler with Dynamic Booking Orchestration
Manages the execution of queued reservations with 3 browsers and staggered refresh
"""

import threading
import time
import logging
import pytz
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Any
import asyncio

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Use the now-async SpecializedBrowserPool
from browser_pool_specialized import SpecializedBrowserPool
from lvbot.utils.booking_orchestrator import DynamicBookingOrchestrator
from lvbot.utils.browser_allocation import BrowserAllocationHelper
from lvbot.utils.browser_refresh_manager import BrowserRefreshManager
from lvbot.utils.tennis_executor import TennisExecutor, create_tennis_config_from_user_info


class ReservationScheduler:
    """
    Background scheduler that executes reservations at the 48-hour mark
    Uses 3 browsers with staggered refresh rates for optimal booking success
    """
    
    def __init__(self, config, queue, notification_callback, bot_handler=None, browser_pool=None):
        # Support both old and new initialization patterns
        if bot_handler:
            self.bot = bot_handler
            self.config = bot_handler.config
            self.queue = bot_handler.queue
            self.user_db = bot_handler.user_db
            self.notification_callback = bot_handler.send_notification_sync
        else:
            # Old style initialization
            self.bot = None
            self.config = config
            self.queue = queue
            self.user_db = None
            self.notification_callback = notification_callback
        
        self.logger = logging.getLogger('ReservationScheduler')
        
        # Thread control
        self.running = False
        self.scheduler_thread = None
        
        # Dynamic booking orchestrator
        self.orchestrator = DynamicBookingOrchestrator()
        
        # Use pre-initialized browser pool if provided, otherwise will initialize lazily
        self.browser_pool = browser_pool
        self._pool_initialized = browser_pool is not None
        
        if self.browser_pool:
            self.logger.info("Using pre-initialized browser pool from main thread")
            # Set global browser pool for smart executor
            
        
        # Browser refresh manager (initialized with pool)
        self.refresh_manager = None
        
        # Performance tracking
        self.stats = {
            'total_attempts': 0,
            'successful_bookings': 0,
            'failed_bookings': 0,
            'avg_execution_time': 0
        }
    
    @staticmethod
    def _get_reservation_field(reservation: Dict[str, Any], field: str, default: Any = None) -> Any:
        """
        Safe getter for reservation dictionary fields
        
        Provides consistent access to reservation data following DRY principles.
        This centralizes dictionary access patterns used throughout the class.
        
        Args:
            reservation: Reservation dictionary
            field: Field name to retrieve
            default: Default value if field doesn't exist
            
        Returns:
            Field value or default
        """
        return reservation.get(field, default)
    
    async def _ensure_browser_pool(self):
        """Ensure browser pool is initialized (lazy initialization)"""
        if not self._pool_initialized:
            self.logger.info("Browser pool not initialized, initializing now...")
            await self._initialize_browser_pool()
            self._pool_initialized = True
        else:
            self.logger.debug("Browser pool already initialized")
            
    async def _initialize_browser_pool(self):
        """Initialize persistent browser pool with 3 browsers"""
        try:
            self.logger.info("Initializing persistent browser pool")
            
            # Create browser pool directly in main thread (required by Playwright)
            self.browser_pool = await self._create_and_initialize_browser_pool_async()
            
            if self.browser_pool:
                self.logger.info(f"Browser pool initialized successfully: {self.browser_pool}")
                # Set global browser pool for smart executor
                # from lvbot.utils.smart_tennis_executor import set_global_browser_pool
                # set_global_browser_pool(self.browser_pool)
                self.logger.info("Browser pool initialized (smart executor disabled)")
            else:
                self.logger.error("Browser pool creation returned None")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize browser pool: {e}")
            self.browser_pool = None
    
    async def _create_and_initialize_browser_pool_async(self):
        """Create and initialize browser pool in async context"""
        try:
            # Create pool
            browser_pool = await self._create_browser_pool_async()
            
            if browser_pool:
                # Wait for pool to be ready (this will create browsers)
                self.logger.info("Waiting for browser pool to initialize browsers...")
                if await browser_pool.wait_until_ready(timeout=60):
                    self.logger.info("Browser pool is ready for use")
                    return browser_pool
                else:
                    error = browser_pool.get_initialization_error()
                    self.logger.error(f"Browser pool failed to initialize: {error}")
                    # Still return the pool instance, it might recover
                    return browser_pool
            
            return None
            
        except Exception as e:
            self.logger.error(f"Error in browser pool creation: {e}")
            return None
    
    async def _create_browser_pool_async(self):
        """Create browser pool in async context"""
        try:
            self.logger.info("="*60)
            self.logger.info("INITIALIZING SPECIALIZED BROWSER POOL (ASYNC)")
            self.logger.info("="*60)
            
            browser_pool = SpecializedBrowserPool(
                courts_needed=[1, 2, 3],  # Example: 3 browsers for 3 courts
                headless=True,
                booking_url=self.config.booking_url,
                low_resource_mode=self.config.low_resource_mode,
                persistent=True,  # Keep alive between bookings
                max_browsers=self.config.browser_pool_size # Use config setting
            )
            
            # Start the pool - browsers will open with optimizations
            self.logger.info("Starting specialized browser pool...")
            await browser_pool.start()
            
            self.logger.info("‚úì Specialized browser pool started successfully!")
            self.logger.info("‚úì All browsers initialized with performance optimizations")
            self.logger.info("‚úì Ready for high-speed court checking")
            
            # Initialize refresh manager
            self.refresh_manager = BrowserRefreshManager(
                browser_pool=browser_pool,
                refresh_interval=self.config.browser_refresh_interval
            )
            self.refresh_manager.start()
            self.logger.info(f"‚úì Browser refresh manager started (interval: {self.config.browser_refresh_interval}s)")
            
            return browser_pool
            
        except Exception as e:
            self.logger.error(f"Error creating browser pool: {e}")
            return None
    
    async def start(self):
        """Start the reservation scheduler"""
        self.logger.info("Starting reservation scheduler")
        self.running = True
        
        # Only initialize browser pool if not provided from main thread
        if not self.browser_pool:
            self.logger.info("="*60)
            self.logger.info("STARTUP: Initializing browser pool")
            self.logger.info("="*60)
            await self._ensure_browser_pool()
        else:
            self.logger.info("Using pre-initialized browser pool from main thread")
            # Initialize refresh manager with pre-initialized pool
            if self.config.browser_refresh_interval > 0:
                self.refresh_manager = BrowserRefreshManager(
                    self.browser_pool,
                    refresh_interval=self.config.browser_refresh_interval
                )
                self.refresh_manager.start()
                self.logger.info(f"‚úì Browser refresh manager started (interval: {self.config.browser_refresh_interval}s)")
        
        self.scheduler_thread = threading.Thread(
            target=lambda: asyncio.run(self._scheduler_loop()), # Run async loop in thread
            daemon=True,
            name="ReservationScheduler"
        )
        self.scheduler_thread.start()
        
        self.logger.info("Reservation scheduler started with browser pool ready")
    
    async def stop(self):
        """Stop the scheduler"""
        self.logger.info("Stopping reservation scheduler")
        self.running = False
        
        # Stop browser refresh manager first
        if self.refresh_manager:
            self.refresh_manager.stop()
            self.refresh_manager = None
            
        # Stop persistent browser pool
        if self.browser_pool:
            await self.browser_pool.stop()
            self.browser_pool = None
        
        if self.scheduler_thread:
            self.scheduler_thread.join(timeout=5)
        
        self.logger.info("Reservation scheduler stopped")
    
    async def _scheduler_loop(self):
        """Main scheduler loop that checks for reservations to execute"""
        while self.running:
            try:
                # Get reservations that need to be executed
                pending = self.queue.get_pending_reservations()
                
                # Convert timezone string to tzinfo object for datetime.now()
                tz = pytz.timezone(self.config.timezone)
                now = datetime.now(tz)
                
                # Group reservations by execution time
                time_groups = {}
                for reservation in pending:
                    status = self._get_reservation_field(reservation, 'status')
                    if status in ['scheduled', 'attempting']:
                        scheduled_execution = self._get_reservation_field(reservation, 'scheduled_execution')
                        exec_time = datetime.fromisoformat(scheduled_execution)
                        
                        # Check if it's time to execute
                        if exec_time <= now:
                            # Group by target time for concurrent execution
                            target_date = self._get_reservation_field(reservation, 'target_date')
                            time = self._get_reservation_field(reservation, 'time')
                            key = f"{target_date}_{time}"
                            if key not in time_groups:
                                time_groups[key] = []
                            time_groups[key].append(reservation)
                
                # Execute each time group
                for time_key, reservations in time_groups.items():
                    if reservations:
                        await self._execute_reservation_group(reservations)
                
                # Sleep before next check
                await asyncio.sleep(15)  # Check every 15 seconds
                
            except Exception as e:
                self.logger.error(f"Scheduler error: {e}")
                await asyncio.sleep(30)  # Wait longer on error
    
    async def _execute_reservation_group(self, reservations: List[Any]):
        """
        Execute a group of reservations for the same time slot
        Uses persistent browser pool with dynamic court assignment
        """
        if not reservations:
            return
        
        # Ensure browser pool is initialized
        await self._ensure_browser_pool()
        if not self.browser_pool:
            self.logger.error("Browser pool not available")
            return
        
        # Get time slot info from first reservation
        first_res = reservations[0]
        time_slot = self._get_reservation_field(first_res, 'time', self._get_reservation_field(first_res, 'target_time'))
        target_date_str = self._get_reservation_field(first_res, 'target_date')
        target_date = datetime.fromisoformat(target_date_str)
        
        self.logger.info(f"Executing {len(reservations)} reservations for {time_slot}")
        
        # Enrich reservations with priority information
        # Create a simple class to hold reservation data as attributes
        class ReservationData:
            def __init__(self, data):
                self.__dict__.update(data)
        
        enriched_reservations = []
        for res in reservations:
            user_id = self._get_reservation_field(res, 'user_id')
            
            # Create enriched data
            enriched_data = {
                'id': self._get_reservation_field(res, 'id'),
                'user_id': user_id,
                'courts': self._get_reservation_field(res, 'court_preferences', []),
                'time': self._get_reservation_field(res, 'time', self._get_reservation_field(res, 'target_time')),
                'created_at': datetime.fromisoformat(
                    self._get_reservation_field(res, 'created_at')
                ),
                'priority': self._get_reservation_field(res, 'priority', 2)  # Default to regular if not set
            }
            
            # Override priority based on user status if not already set
            if 'priority' not in res or res.get('priority') is None:
                if self.user_db.is_admin(user_id):
                    enriched_data['priority'] = 0  # Admin
                elif self.user_db.is_vip(user_id):
                    enriched_data['priority'] = 1  # VIP
                else:
                    enriched_data['priority'] = 2  # Regular
            
            # Create object with attributes
            enriched_obj = ReservationData(enriched_data)
            enriched_reservations.append(enriched_obj)
        
        # Create booking plan using orchestrator
        booking_plan = self.orchestrator.create_booking_plan(enriched_reservations, time_slot)
        
        # Log browser pool status
        # Note: AsyncBrowserPool doesn't have court_manager - skip status logging for now
        # pool_status = self.browser_pool.court_manager.get_status_summary()
        # self.logger.info(f"Browser pool status: {pool_status['available_courts']} courts ready")
        
        # Execute bookings using persistent pool
        await self._execute_with_persistent_pool(booking_plan, target_date, reservations)
    
    async def _execute_with_persistent_pool(self, booking_plan: Dict[str, Any], target_date: datetime, reservations: List[Dict[str, Any]]):
        """
        Execute bookings using persistent browser pool with smart court assignment
        """
        browser_assignments = booking_plan['browser_assignments']
        results = {}
        
        # Create lookup for reservations by ID for efficient access
        reservation_lookup = {self._get_reservation_field(res, 'id'): res for res in reservations}
        
        # Process each assignment sequentially (since we have limited browsers)
        for assignment in browser_assignments:
            attempt = assignment['attempt']
            reservation_id = attempt.reservation_id
            
            # Get the original reservation dictionary
            reservation = reservation_lookup.get(reservation_id)
            if not reservation:
                results[reservation_id] = {'success': False, 'error': 'Reservation not found'}
                continue
            
            # Skip if already successful
            if reservation_id in results and results[reservation_id].get('success'):
                continue
            
            try:
                # Get user info
                user_id = self._get_reservation_field(reservation, 'user_id')
                user = self.user_db.get_user(user_id)
                if not user:
                    results[reservation_id] = {'success': False, 'error': 'User not found'}
                    continue
                
                preferred_time = self._get_reservation_field(reservation, 'time')
                target_time = self._get_reservation_field(reservation, 'target_time')
                fallback_times = self._get_reservation_field(reservation, 'fallback_times', [])
                
                user_info = {
                    'email': user.get('email'),
                    'first_name': user.get('first_name'),
                    'last_name': user.get('last_name'),
                    'phone': user.get('phone'),
                    'user_id': user.get('user_id'),
                    'preferred_time': preferred_time,
                    'target_time': target_time,
                    'fallback_times': fallback_times
                }
                
                # Execute booking using persistent pool
                courts = self._get_reservation_field(reservation, 'courts')
                executor = TennisExecutor(browser_pool=self.browser_pool)
                tennis_config = create_tennis_config_from_user_info(user_info)
                result = await executor.execute(
                    tennis_config,
                    target_date,
                    check_availability_48h=False,
                    get_dates=False
                )
                
                # Store result
                results[reservation_id] = result
                
                # Handle result with orchestrator
                if result['success']:
                    self.orchestrator.handle_booking_result(
                        reservation_id,
                        success=True,
                        court_booked=result['court']
                    )
                    self._update_reservation_success(reservation_id, result)
                else:
                    # Try fallback
                    fallback_plan = self.orchestrator.handle_booking_result(
                        reservation_id,
                        success=False
                    )
                    
                    if fallback_plan:
                        await self._execute_fallback(fallback_plan)
                
            except Exception as e:
                self.logger.error(f"Booking execution error for {reservation_id}: {e}")
                results[reservation_id] = {'success': False, 'error': str(e)}
        
        # Handle overflow users if any
        overflow_count = booking_plan.get('overflow_count', 0)
        if overflow_count > 0:
            self.logger.info(f"Processing {overflow_count} overflow reservations")
            # Overflow users will be processed as browsers become available
        
        # Log summary
        summary = self.orchestrator.get_booking_summary()
        self.logger.info(f"Booking execution complete: {summary}")
        
        # Notify users of results
        await self._notify_booking_results(results)
    
    
    async def _execute_fallback(self, fallback_plan: Dict):
        """Execute a fallback booking attempt using persistent pool"""
        reservation_id = fallback_plan['reservation_id']
        fallback_court = fallback_plan['fallback_court']
        
        self.logger.info(f"Executing fallback for {reservation_id} on court {fallback_court}")
        
        # Get reservation and user info
        reservation = self._get_reservation_by_id(reservation_id)
        if not reservation:
            return
        
        user_id = self._get_reservation_field(reservation, 'user_id')
        user = self.user_db.get_user(user_id)
        if not user:
            return
        
        # Prepare user info
        preferred_time = self._get_reservation_field(reservation, 'time')
        target_time = self._get_reservation_field(reservation, 'target_time')
        fallback_times = self._get_reservation_field(reservation, 'fallback_times', [])
        
        user_info = {
            'email': user.get('email'),
            'first_name': user.get('first_name'),
            'last_name': user.get('last_name'),
            'phone': user.get('phone'),
            'user_id': user.get('user_id'),
            'preferred_time': preferred_time,
            'target_time': target_time,
            'fallback_times': fallback_times
        }
        
        # Attempt booking on fallback court using pool
        attempt = self.orchestrator.active_attempts.get(reservation_id)
        if attempt and self.browser_pool:
            # Update attempt's target court
            attempt.target_court = fallback_court
            
            # Execute using browser pool
            executor = TennisExecutor(browser_pool=self.browser_pool)
            # Prepare user_info for create_tennis_config_from_user_info
            user_info['court_preference'] = fallback_plan.get('remaining_fallbacks', [])
            user_info['preferred_times'] = [preferred_time]
            tennis_config = create_tennis_config_from_user_info(user_info)
            
            target_date_str = self._get_reservation_field(reservation, 'target_date')
            target_date = datetime.fromisoformat(target_date_str)

            result = await executor.execute(
                tennis_config,
                target_date,
                check_availability_48h=False,
                get_dates=False
            )
            
            if result['success']:
                self.orchestrator.handle_booking_result(
                    reservation_id,
                    success=True,
                    court_booked=result['court']
                )
                self._update_reservation_success(reservation_id, result)
            else:
                # Try next fallback if available
                next_fallback = self.orchestrator.handle_booking_result(
                    reservation_id,
                    success=False
                )
                if next_fallback:
                    await self._execute_fallback(next_fallback)
    
    def _update_reservation_success(self, reservation_id: str, result: Dict):
        """Update reservation status to completed"""
        self.queue.update_reservation_status(reservation_id, 'completed')
        self.stats['successful_bookings'] += 1
        self.logger.info(f"Reservation {reservation_id} completed successfully")
    
    async def _notify_booking_results(self, results: Dict[str, Any]):
        """Send notifications to users about booking results"""
        for reservation_id, result in results.items():
            reservation = self._get_reservation_by_id(reservation_id)
            if not reservation:
                continue
            
            user_id = self._get_reservation_field(reservation, 'user_id')
            user = self.user_db.get_user(user_id)
            if not user:
                continue
            
            # Format notification message
            target_date = self._get_reservation_field(reservation, 'target_date')
            time = self._get_reservation_field(reservation, 'time')
            
            if result.get('success'):
                court = result.get('court', 'Unknown')
                message = (
                    f"‚úÖ **Reservation Successful!**\\n\\n"
                    f"üéæ Court {court} booked\\n"
                    f"üìÖ {target_date}\\n"
                    f"‚è∞ {time}\\n\\n"
                    f"See you on the court!"
                )
            else:
                error = result.get('error', 'Unknown error')
                message = (
                    f"‚ùå **Reservation Failed**\\n\\n"
                    f"üìÖ {target_date} at {time}\\n"
                    f"Reason: {error}\\n\\n"
                    f"Please try booking manually or contact support."
                )
            
            # Send notification (async)
            await self.bot.send_notification(user_id, message)
    
    def _get_reservation_by_id(self, reservation_id: str):
        """Get reservation by ID from queue"""
        pending = self.queue.get_pending_reservations()
        for res in pending:
            if res.get('id') == reservation_id:
                return res
        return None
    
    def get_performance_report(self) -> str:
        """Get scheduler performance statistics"""
        success_rate = (
            (self.stats['successful_bookings'] / self.stats['total_attempts'] * 100)
            if self.stats['total_attempts'] > 0 else 0
        )
        
        report = (
            f"üìä **Performance Statistics**\\n\\n"
            f"üéØ Success Rate: {success_rate:.1f}%\\n"
            f"‚úÖ Successful: {self.stats['successful_bookings']}\\n"
            f"‚ùå Failed: {self.stats['failed_bookings']}\\n"
            f"üìà Total Attempts: {self.stats['total_attempts']}\\n"
        )
        
        # AsyncBrowserPool doesn't have get_stats method - comment out for now
        # if self.browser_pool:
        #     # get_stats might need to be async if it uses Playwright
        #     pool_stats = self.browser_pool.get_stats()
        #     report += (
        #         f"\\nüåê **Browser Pool Status**\\n"
        #         f"Browsers Created: {pool_stats['browsers_created']}\\n"
        #         f"Browsers Recycled: {pool_stats['browsers_recycled']}\\n"
        #     )
        
        return report
